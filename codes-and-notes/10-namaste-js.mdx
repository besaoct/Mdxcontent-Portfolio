---
title: Namaste JavaScript first Season notes
date: 2023-10-19
tags: ['js','javascript']
---

### Episode 1 : Execution Context

#### Everything in JS happens inside the execution context. 

Assume execution context to be a big box where everything takes place. It has 2 components in it:
<li> <strong>Memory : </strong>The place where all the variables and functions are stored as (key:value) pairs. Memory component is also known as <em>variable environment</em>.
<li> <strong>Code : </strong>The place where code is executed one line at a time. Code component is also known as <em>Thread of Execution</em>

#### JS is a synchronous single-threaded language. 
<li> By single threaded, we mean JS can only run 1 command at a time
<li> By synchronous single threaded, we mean it can run 1 command at a time, <em>in a specific order</em>



### Episode 2 : Execution & Call Stack

Everytime you run a program, an execution context is created.
When a variable or function is encountered, it is stored in the memory area. 

```js
var n=2;
function square(num){
    var ans = num*num;
    return ans;
}

var square2 = square(n);
var square4 = square(4);

```
Now first, for this entire code a <strong>Global</strong> execution context is created.

#### In the first phase (memory creation)
- Memory is allocated to variables and functions.
- For variable name(which is key) it assigns a value of <strong>undefined</strong>
- For the function name(which is key) it assigns the entire function code as value.

```js
n:undefined 
square:{...entire-code...}
square2:undefined 
square4:undefined

```

#### In the second phase (code execution)
- The variable name is replaced with its actual assigned value from code. So now n:2 
- Skips over function code as there is nothing to assign there. 
- We encounter a function call in square2. So a brand new local EC is created inside the code part of global EC and this will have the same 2 components: Memory and Code. 
- In the local EC, ans and num are both undefined (in first phase). Then, the n value in global EC is passed to num, replacing undefined. num is the parameter and n is the argument. 
- ans = num*num (calculated in code part of local EC and returned) replaces undefined in local EC (memory part) and the final value is returned from local and is assigned to square2 var in global. 
  After returning, local EC is removed form global EC and control goes back to global.
- One more fun. call is met. Same thing happens here. 
Once square4 value is replaced from undefined to 16, global EC will also be deleted. 

To manage all these EC, a call **stack** is created. Everytime code is run, the EC is pushed in. So first global EC is pushed. Then e1 EC(for square2) is pushed, and then after
value returned, is popped. Similarly e2 EC(for square4) is pushed, and then popped and finally Global is also popped and stack is empty. 

> Call Stack maintains the order of execution of execution contexts
##### Call stack aka Execution control stack, program stack, control stack, runtime stack ad machine stack




### Episode 3 : Hoisting


```js
// code example 1

var x = 7;

function getName(){
    console.log("Namaste JavaScript");
}

getName();
console.log(x);

```

Output:

> Namaste JavaScript

> 7


```js

// code example 2

getName();      // in most languages, both lines which are above their declaration will give error. Not in JS though.
console.log(x);

var x = 7;

function getName(){
    console.log("Namaste JavaScript");
}

```

Output:

> Namaste JavaScript

> undefined


```js
// code example 3

getName();
console.log(x);

function getName(){
    console.log("Namaste JavaScript");
}

```

Output:

> Namaste JavaScript

> Error: x is not defined // note that not defined here and "undefined" in
> sample 2 are totally different.

- Not defined: We have not initialised the value for variable anywhere in the
  entire code and in memory space.
- Undefined: It is a placeholder that is assigned to a variable by the
  Javascript Engine until the variable is assigned with some other value.

**Hoisting** is a concept which enables us to extract values of variables and
functions even before initialising/assigning value without getting _error_

```js

// code example 4

function getName(){
    console.log("Namaste JavaScript");
}

console.log(getName)


```

Output:

```js
>f getName(){

      console.log("Namaste JavaScript");

}

```


```js
// code example 5
getName();
console.log(x);
console.log(getName)

var x = 7;

function getName(){
    console.log("Namaste JavaScript");
}

```

Output:

```js
> Namaste JavaScript

> undefined

> f getName(){

      console.log("Namaste JavaScript");

}
```

```js
// code example 6

console.log(getName)

var getName = function () {
    console.log("Namaste JavaScript");
}

var getName = () => {  // use fat arrow function
    console.log("Namaste JavaScript");
}

```

Output:

```js
> undefined //it is because they behave as variable and not function.
```

---

**REASON OF WEIRDNESS**

- The answer lies in the Global Exection Context. In the memory phase, the
  variables will be initialized as _undefined_ and functions will get the whole
  function code in their memory.

- This is the reason why we are getting these outputs.



### Episode 4 : Functions and Variable Environments

```js
var x = 1;
a();
b();   // we are calling the functions before defining them. This will work properly, as seen in Hoisting (Ep3)
console.log(x);

function a() {
  var x = 10;
  console.log(x);
}


function b() {
  var x = 100;
  console.log(x);
}

```

Outputs:

> 10

> 100

> 1

#### Code Flow

- The Global Execution Context (GEC) is created (the big box with Memory and Code subparts). Also GEC is pushed into Call Stack
> Call Stack : GEC
- In first phase of GEC (memory phase), variable x:undefined and a and b have their entire function code as value initialized
- In second phase of GEC (execution phase), when the fun is called, a new local EC is made. After x = 1 assigned to GEC x, a() is called. So local EC for a is made inside code part of GEC.
> Call Stack: [GEC,a()]
- For local EC, a totally different x variable assigned undefined(x inside a()) in phase 1 , and in phase 2 it is assigned 10 and printed in console log. After printing, no more
commands to run, so a() local EC is removed from both GEC and from Call stack
> Call Stack: GEC
- Cursor goes back to b() function call. Same steps repeat.
> Call Stack :[GEC, b()] -> GEC (after printing yet another totally different x value as 100 in console log)
- Finally GEC is deleted and also removed from call stack. Program ends.


### Episode 5: Window and this keyword

#### Everywhere JS is run, it is done with a JS execution engine. For Chrome: v8

- Shortest JS program is nothing but an Empty JS file
- Even for this program, JS engine does a lot behind the scenes
- It creates the GEC, the "window" and the *this* variable
- Window is a big global object that has a lot of functions and variables. All of these can be accessed from anywhere in the program
- *this* points to *window*
> this === window -> true (at global level)

```js
var a = 10;      // not inside any fun. So global object
function b() {    // this fun not inside any function. So global.
  var x = 5;    // not global
 }
console.log(window.a); //gives us "a" value
console.log(this.a); //this points to window so it returns "a" value
console.log(a); //also gives same "a" value. (if we dont put any . in front of variable, it **assumes variable is in global space**
console.log(x); // x is not defined. (tries to find x inside global space, but it isn't there) 
```
- Global space is anything in JS which isn't inside a function. All these global objects will be present inside the windows schema. But non globals ones won't be there (here, x)
- When a GEC is made, *this* is also created with it (even for functional(local) EC). Global object provided by the browser engine is the window, so *this* points to window.


### Episode 6: Undefined vs Not Defined

- In first phase (mem alloc) JS assigns each variable to a placeholder called *undefined*
- *undefined* is when memory is allocated for the variable, but no value is assigned yet.
- If an object/variable is not even declared/found in mem alloc phase, and tried to access it then it is *Not defined*

> When variable is declared but not assigned value, its current value is undefined. But when the variable itself is not declared but called in code, then it is not defined. 

```js
console.log(x);
var x = 25;

console.log(x);
console.log(a);

```
Output:

>undefined <br/>
>25 <br/>
>Uncaught ReferenceError: a is not defined


- JS is a loosely-typed / weakly-typed language. It doesn't attach variables to any datatype. We can say var a = 5, and then change the value to bool (a = true) or string
(a = 'hello') later on. 
- **Never** assign *undefined* to a variable manually. Let it happen on it's own accord.


### Episode 7 : Scope and Lexical Environment

```js
This is why JS is confusing (Case-1)

function a() {
    console.log(b); // surprisingly instead of printing undefined it prints 10. 
    //So somehow this b could access the b outside the fun. 
}

var b = 10;
a();

// ---------------------

Another case: (Case-2)

function a() {
  c();
  function c() {
  console.log(b); // when cursor comes here, it still prints out 10 somehow!!
  }
 }
 var b = 10;
 a();
 
//  --------------------
 
 Another one (DJ KHALED!) (Case-3)
 
 function a() {
  var b = 10;
  c();
  function c() {
    console.log(b); //it prints the right value. How? See ans below Summary part
  }
 }
 
 a();
 console.log(b); // now when cursor comes here, it prints NOT DEFINED!

```

- This is the intuition behind **scope**
- Scope is directly dependent on the lexical environment
- **Lexical Environment** : local memory + lexical env of its parent
- Whenever an EC is created, a Lexical environment(LE) is also created and is referenced in the local EC(in memory space)
- Lexical means hierarchy. In the DJ KHALED (xD) code, function c is lexically inside function a. 
- So in EC of c(), variables and fun in c (none) + reference of lexical env of parent a() is there
- LE of a() in turn is its memory space + reference to LE of parent (Global EC)
- LE of Global EC points to *null*

 ```js
    To summarize the above points:
    
    call_stack = [GEC, a(), c()]

    Now lets also assign the memory sections of each execution context in call_stack.

    c() = [[lexical environment pointer pointing to a()]]

    a() = [b:10, c:{}, [lexical environment pointer pointing to GEC]]

    GEC =  [a:{},[lexical_environment pointer pointing to null]]

 ```
 
  #### For case -3 
  - First JS engine searches for b in local mem of c(). Nothing is there. 
  - So it goes to the reference of Lexical env of parent a(). Here b = 10 is here. So it takes this value, goes back to c() and console prints it.
  - Had b not been in a(), then pointer would have gone to a()'s parent (Global EC and searched there). Had b not been there too, then it goes to LE of global's parent
  which is null. Now JS engine stops and says b is NOT DEFINED. 
  - **Lexical env of c = Local memory of c + LE of A + LE of Global**
  - This process of going one by one to parent and checking is called **scope chain**
 
  

### Episode 8 : let, const, temporal dead zone, types of errors

> let and const declarations are hoisted. But its different from var

```js

console.log(a); // ReferenceError: Cannot access 'a' before initialization
console.log(b); // prints undefined as expected
let a = 10;
console.log(a); // 10
var b = 15;

```
It looks like let isn't hoisted, **but it is**

- Both a and b are actually initialized as *undefined* in hoisting stage. But var b is inside the storage space of GLOBAL, and a is in a separate memory(script), where it can be
accessed only after assigning some value to it first.
- ie. one can access 'a' only if it is assigned. Thus, it throws error.
- **Temporal Dead Zone** : Time since when the let variable was hoisted until it is initialized some value. 
- So any line till before "let a = 10" is the TDZ for a
- Since a is not accessible on global, its not accessible in *window/this* also
> window.b or this.b -> 15; But window.a or this.a ->undefined, just like window.x->undefined (x isn't declared anywhere)

```js
let a = 10;
let a = 100;  //this code is rejected upfront as SyntaxError. (duplicate declaration)
------------------
let a = 10;
var a = 100; // this code also rejected upfront as SyntaxError.
// (can't use same name in same scope)

```

Let is a stricter version of var. Now, **const** is even more stricter than let.

-const holds all above properties of let. 

```js
let a;
a = 10;
console.log(a) // prints 10 properly. Note declaration and assigning of a is in different lines.
------------------
const b;
b = 10;
console.log(b); // SyntaxError: Missing initializer in const declaration.
// (This type of declaration won't work with const. const b = 10 only will work)
------------------
const b = 100;
b = 1000;
//this gives us TypeError: Assignment to constant variable. 

```

- Till now 3 types of errors have been covered: Syntax, Reference, and Type.

* Uncaught ReferenceError: x is not defined at ...

    * This Error signifies that x has never been in the scope of the program. This literally means that x was never defined/declared and is being tried to be accesed.

* Uncaught ReferenceError: cannot access 'a' before initialization

    * This Error signifies that 'a' cannot be accessed because it is declared as 'let' and since it is not assigned a value, it is its Temporal Dead Zone. Thus, this error occurs.

* Uncaught SyntaxError: Identifier 'a' has already been declared

    * This Error signifies that we are redeclaring a variable that is 'let' declared. No execution will take place.

        ```js
        //code example 1.1
        let a=10;
        let a=100;
        ```
        ```js
        //code example 1.2
        let a=10;
        var a=100;
        ```
    
        Will throw this Syntax error and no code will be run and be rejected affront. 
        'let' is a strict form of declaration and thus can be done only once.
* Uncaught SyntaxError: Missing initializer in const declaration
    * This Error signifies that we haven't initialized or assigned value to a const declaration.

* Uncaught TypeError: Assignment to constant variable
    * This Error signifies that we are reassigning to a const variable.


#### Type Error:

The Errors that occur due to conflicts with the declaration type. For example re-assigning const type declaration will throw this.

#### Syntax Error:

The Errors that occur due to wrong syntax that doesn't match with JS Engine syntactical rules. 

For example, if const is not initialized, it will throw syntax error as by syntax, it must initialize if it sees a const declaration.

Also, if variable that is assigned with 'let' declaration is tried to re-declared, then it throws Syntax Error.

#### Reference Error

The Errors that occurs if no reference is available for access. Can occur when the variable is no where in scope or maybe it is in temporal dead zone.


#### SOME GOOD PRACTICES:

* Try using const wherever possible.
* If not, use let.
* Avoid var.
* Declare and initialize all variables with let to the top to avoid errors to shrink temporal dead zone window to zero.

PS: If in any interview when asked "Are let and const hoisted?" explain fully about temporal deadzone and all the above concepts too


### Episode 9 : Block Scope and Shadowing

#### What is a block?
- Block aka *compound statement* is used to group JS statements together into 1 group. We group them within {...}
- The purpose is to group multiple statments at a place where JS expects only 1 statement.

```js
//code example 1

if(true)some statement

```

But if we want to write more statements to execute after if condition; then:

```js
//code example 2

if(true){
    statement 1
    statement 2
    ...
}
```

* The {} block treats all the statements as one statement.
* The if doesnt have any curly braces in syntax.

#### __BLOCK SCOPE__

* What are the variables and functions that can be accessed inside the block.

```js
//code example 3

{
    var a = 10;
    let b = 20;
    const c = 30;
}

console.log(a);
console.log(b);
```

Outputs:

> 10

> Uncaught ReferenceError: b is not defined

* Behind the Scenes:

    * In the BLOCK SCOPE; we get b and c inside it initialized as *undefined* as a part of hoisting (in a seperate memory space called block)
    * While, a is stored inside a GLOBAL scope. 

* Thus we say, *let* and *const* are BLOCK SCOPED. They are stored in a separate mem space which is reserved for this block. Also, they can't be accessed outside this block.
But var a can be accessed anywhere as it is in global scope.
* Thus, we can't access them outside the Block.

#### __What is SHADOWING in JS?__

```js
//code example 4

var a = 100;
{
    var a = 10; //same name as global var
    let b = 20;
    const c = 30;
    console.log(a); // 10
    console.log(b); // 20
    console.log(c); // 30 
}

console.log(a); // 10 instead of the 100 we were expecting. So block "a" modified val of global "a" as well. 
// In console, only b and c are in block space. a initially is in global space(a = 100), and when a = 10 line is run, a is not created in block space, but replaces 100 with 10 in global space itself. 
```

* If one has same named variable outside the block, the variable inside the block *shadows* the outside variable.
* So, a is reassigned to 10. Since both refers to same memory space i.e GLOBAL SPACE. **This happens only for var**

#### Instead of var let us use let
```js
//code example 5

let b = 100;
{
    var a = 10;
    let b = 20;
    const c = 30;
    console.log(b);
}

console.log(b);
```

Outputs:

> 20

> 100  // this was what we were expecting in this first place. Both b's are in separate spaces (one in Block(20) and one in Script(another arbitrary mem space)(100))

* In the Scope, we have b in two places. The b outside of the block is in *Script* SCOPE (seperate memory space for let and const)
* The b inside the block is in *Block* scope.
* Thus, when in Block scope, 20 is printed and 100 when outside.
* This concept is called "Shadowing".
* It is also true for *const* declarations.

#### Same logic is true even for functions

```js
const c = 100;
function x() {
  const c = 10;
  console.log(c);
}
x();
console.log(c);

```
Output:
> 10

> 100

#### __What is Illegal Shadowing?__

```js
// code example 6

let a = 20;
{
    var a = 20;
}

```

Outputs:

> Uncaught SyntaxError: Identifier 'a' has already been declared

* We cannot shadow let with var. But it is valid to shadow a let using a let.
* However, we can shadow var with let.
* All scope rules that work in function are same in arrow functions too.
* Since var is function scoped, it is not a problem with the code below.

```js
// code example 7

let a = 20;
function x() {
    var a = 20;
}

```


### Episode 10 : Closures in JS

#### Important Interview Question

**Closure :** Function bundled together with its lexical environment/scope.

```js
JS is a weird language. You can pass functions as parameters to another function, assign a variable to an entire function, or even return a function.
eg:

function x() {
  var a = 7;
  function y() {
  console.log(a);
}
  return y;   // instead of y();
}
var z = x();
console.log(z);  // value of z is entire code of function y.

```

When functions are returned from another fun, they still maintain their lexical
scope.

- When y is returned, not only is the fun returned but the entire closure (fun
  y + its lexical scope) is returned and put inside z. So when z is used
  somewhere else in program, it still remembers var a inside x()
- Closure is a very powerful concept of JS, just because this function remembers
  things even if they are not in their lexical scope

#### Uses of Closure

Module Design Pattern, Currying, Functions like once(fun that can be run only
once), memoize, maintaining state in async world, setTimeout, iterators etc..